<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprigatitonyan's Adventure 3D</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-areas:
                "header header"
                "main sidebar";
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            padding: 1rem;
        }
        #canvas-container {
            grid-area: main;
            position: relative;
            min-height: 0;
            border-radius: 12px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .stats-panel {
            grid-area: sidebar;
            background-color: #2d3748;
            border: 4px solid #4a5568;
            border-radius: 12px;
            padding: 1.5rem;
            overflow-y: auto;
        }
        .game-header {
            grid-area: header;
            text-align: center;
        }
        .message-box {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7); color: white;
            padding: 15px 25px; border-radius: 10px;
            opacity: 0; transition: opacity 0.5s; z-index: 100;
            max-width: 80%; text-align: center;
        }
        .boss-health-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 20px;
            background-color: #4a5568;
            border: 2px solid #a0aec0;
            border-radius: 10px;
            z-index: 50;
            display: none;
        }
        .boss-health-bar-inner {
            width: 100%; height: 100%;
            background-color: #c53030;
            border-radius: 8px;
            transition: width 0.5s ease;
        }
        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10vw;
            font-family: 'Press Start 2P', cursive;
            color: yellow;
            text-shadow: 0 0 10px white, 0 0 20px yellow, 0 0 30px #ffc107;
            z-index: 1001;
            animation: flash 1s infinite;
            display: none;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="game-container" style="opacity: 1;">
        <header class="game-header">
            <h1 class="text-xl md:text-3xl font-bold text-white">Sprigatitonyan's Adventure 3D</h1>
            <p id="instructions" class="text-xs md:text-sm mt-2">Arrows: Move | Y/A/T: Attacks | G: Taunt</p>
        </header>

        <main id="canvas-container">
            <div id="boss-health-bar"><div id="boss-health-bar-inner"></div></div>
            <canvas id="game-canvas"></canvas>
        </main>

        <aside class="stats-panel">
            <h2 class="text-2xl font-bold text-white mb-6 border-b-2 border-gray-600 pb-2">STATS</h2>
            <div id="player-stats" class="space-y-4 text-sm">
                <div><span class="font-bold text-green-400">Name:</span><span id="stat-name" class="float-right text-white"></span></div>
                <div><span class="font-bold text-red-400">HP:</span><span id="stat-hp" class="float-right text-white"></span></div>
                <div><span class="font-bold text-yellow-400">Attack:</span><span id="stat-attack" class="float-right text-white"></span></div>
                <div><span class="font-bold text-blue-400">Level:</span><span id="stat-level" class="float-right text-white"></span></div>
                <div><span class="font-bold text-purple-400">Rank:</span><span id="stat-rank" class="float-right text-white"></span></div>
                <div class="border-t border-gray-600 pt-4 mt-4">
                    <div class="font-bold text-pink-400">Special Attacks</div>
                    <div id="attack-list" class="text-xs mt-2 space-y-1">
                         <div>Y: Smoked Salmon Blade</div>
                         <div id="paws-of-fury-ui" class="hidden">A: Paws of Fury</div>
                         <div id="cat-wave-ui" class="hidden">T: Cat Wave</div>
                         <div id="taunt-ui" class="hidden">G: âœ¨ Taunt Boss</div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <div id="win-message" class="win-message">YOU WIN!!!</div>
    <div id="message-box" class="message-box"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- Game Configuration ---
        const MAP_SIZE = 8;
        const TILE_SIZE = 10;
        const MAP_DIM = MAP_SIZE * TILE_SIZE;
        const BOSS_TRIGGER_COUNT = (MAP_SIZE * MAP_SIZE) - 10;
        const KILLS_PER_RANK = 10;
        const RANK_ORDER = ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'S'];
        let gameOver = false;
        let bossFightActive = false;
        let bossAttackInterval = null;
        let isAudioStarted = false;

        // --- Game State ---
        const player = {
            name: 'Sprigatitonyan', level: 1, baseHp: 1000, baseAttack: 300, hp: 1000, attack: 300,
            gridX: 4, gridY: 4, isMoving: false, isAttacking: false, 
            pawsOfFuryUnlocked: false, catWaveUnlocked: false,
            killCount: 0, rank: 'G', mesh: null, aura: null,
            isEvolved: false, materials: {},
            targetPosition: new THREE.Vector3(),
            startPosition: new THREE.Vector3(),
            moveProgress: 0,
            updateStats: function() {
                const oldMaxHp = this.baseHp + (this.level - 2) * 10;
                const newMaxHp = this.baseHp + (this.level - 1) * 10;
                this.hp += newMaxHp - oldMaxHp;
                if (this.hp > newMaxHp) this.hp = newMaxHp;
                this.attack = this.baseAttack + (this.level - 1) * 30;
            }
        };
        const enemies = [];
        let nextEnemyId = 0;
        let boss = null;
        const activeEffects = [];

        // --- DOM Elements ---
        const messageBox = document.getElementById('message-box');
        const pawsOfFuryUI = document.getElementById('paws-of-fury-ui');
        const catWaveUI = document.getElementById('cat-wave-ui');
        const tauntUI = document.getElementById('taunt-ui');
        const instructionsElement = document.getElementById('instructions');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthBarInner = document.getElementById('boss-health-bar-inner');
        const winMessageElement = document.getElementById('win-message');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const canvas = document.getElementById('game-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        const cameraOffset = new THREE.Vector3(0, 80, 60);
        camera.position.copy(cameraOffset);
        
        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(20, 50, 30);
        scene.add(dirLight);

        // --- World Creation ---
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(MAP_DIM + 20, MAP_DIM + 20),
            new THREE.MeshStandardMaterial({ color: 0x66CDAA })
        );
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
        
        // --- Player Creation (Jibanyan Style) ---
        function createPlayer() {
            const group = new THREE.Group();
            player.materials.body = new THREE.MeshStandardMaterial({ color: 0xd9534f, roughness: 0.6 });
            player.materials.belly = new THREE.MeshStandardMaterial({ color: 0xffe066, roughness: 0.7 });
            player.materials.flame = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500 });
            player.materials.paw = new THREE.MeshStandardMaterial({ color: 0xffffff });
            player.materials.eye = new THREE.MeshBasicMaterial({ color: 0x000000 });
            player.materials.nose = new THREE.MeshStandardMaterial({ color: 0xffc0cb });
            player.materials.collar = new THREE.MeshStandardMaterial({color: 0x5bc0de});
            player.materials.bell = new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.5});
            player.materials.nick = new THREE.MeshStandardMaterial({color: 0x8c3835});

            const bodyGeo = new THREE.CapsuleGeometry(3, 2, 4, 16);
            const body = new THREE.Mesh(bodyGeo, player.materials.body);
            body.position.y = 2.5;
            group.add(body);

            const headGeo = new THREE.SphereGeometry(3.5, 16, 16);
            const head = new THREE.Mesh(headGeo, player.materials.body);
            head.position.y = 6;
            group.add(head);

            const muzzleGeo = new THREE.SphereGeometry(2, 16, 16);
            const muzzle = new THREE.Mesh(muzzleGeo, player.materials.paw);
            muzzle.position.set(0, 5.5, 2);
            muzzle.scale.y = 0.8;
            group.add(muzzle);

            const eyeGeo = new THREE.CircleGeometry(0.8, 16);
            const eyeL = new THREE.Mesh(eyeGeo, player.materials.eye);
            eyeL.position.set(-1.5, 6.5, 3.3);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, player.materials.eye);
            eyeR.position.set(1.5, 6.5, 3.3);
            group.add(eyeR);

            const noseGeo = new THREE.ConeGeometry(0.5, 0.7, 4);
            const nose = new THREE.Mesh(noseGeo, player.materials.nose);
            nose.position.set(0, 6, 3.8);
            nose.rotation.x = Math.PI / 2;
            group.add(nose);

            const armGeo = new THREE.CylinderGeometry(0.8, 0.6, 2.5, 8);
            const pawGeo = new THREE.SphereGeometry(1.2, 8, 8);

            const armL = new THREE.Mesh(armGeo, player.materials.body);
            armL.name = "armL";
            armL.position.set(-3.5, 3.5, 0);
            armL.rotation.z = Math.PI / 2;
            group.add(armL);
            const pawL = new THREE.Mesh(pawGeo, player.materials.paw);
            pawL.name = "pawL";
            pawL.position.set(-4.5, 3.5, 0);
            group.add(pawL);

            const armR = new THREE.Mesh(armGeo, player.materials.body);
            armR.name = "armR";
            armR.position.set(3.5, 3.5, 0);
            armR.rotation.z = -Math.PI / 2;
            group.add(armR);
            const pawR = new THREE.Mesh(pawGeo, player.materials.paw);
            pawR.name = "pawR";
            pawR.position.set(4.5, 3.5, 0);
            group.add(pawR);

            const bellyGeo = new THREE.CylinderGeometry(3.1, 3.1, 2.5, 16);
            const belly = new THREE.Mesh(bellyGeo, player.materials.belly);
            belly.position.y = 2.5;
            group.add(belly);

            const earGeo = new THREE.ConeGeometry(1.8, 4, 4);
            const earL = new THREE.Mesh(earGeo, player.materials.body);
            earL.position.set(-2.5, 9, 0);
            earL.rotation.z = -Math.PI / 10;
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, player.materials.body);
            earR.position.set(2.5, 9, 0);
            earR.rotation.z = Math.PI / 10;
            
            const nickL = new THREE.Mesh(new THREE.SphereGeometry(0.5), player.materials.nick);
            nickL.position.set(-3.5, 9.5, 0.5);
            group.add(nickL);

            const collar = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.3, 8, 32), player.materials.collar);
            collar.position.y = 4.5;
            collar.rotation.x = Math.PI / 2;
            group.add(collar);
            const bell = new THREE.Mesh(new THREE.SphereGeometry(0.6), player.materials.bell);
            bell.position.set(0, 4.5, 3.5);
            group.add(bell);

            for (let i = -1; i <= 1; i += 2) {
                const tailGroup = new THREE.Group();
                const tailCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 2, -2.5),
                    new THREE.Vector3(i * 2, 3, -4),
                    new THREE.Vector3(i * 3, 4, -6)
                ]);
                const tailGeo = new THREE.TubeGeometry(tailCurve, 20, 0.4, 8, false);
                const tail = new THREE.Mesh(tailGeo, player.materials.body);
                tailGroup.add(tail);

                const flame = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), player.materials.flame);
                flame.position.copy(tailCurve.getPoint(1));
                tailGroup.add(flame);
                group.add(tailGroup);
            }

            player.mesh = group;
            const startPos = gridToWorld(player.gridX, player.gridY);
            player.mesh.position.copy(startPos);
            player.targetPosition.copy(startPos);
            player.startPosition.copy(startPos);
            scene.add(group);
        }

        // --- UI Update ---
        function updateStatsUI() {
            document.getElementById('stat-name').textContent = player.name;
            document.getElementById('stat-hp').textContent = player.hp;
            document.getElementById('stat-attack').textContent = player.attack;
            document.getElementById('stat-level').textContent = player.level;
            document.getElementById('stat-rank').textContent = player.rank;
            
            if (player.level >= 2 && !player.pawsOfFuryUnlocked) {
                player.pawsOfFuryUnlocked = true;
                pawsOfFuryUI.classList.remove('hidden');
                showMessage("Learned Paws of Fury! Press 'A' to use!", 3000);
            }
            if (player.level >= 30 && !player.catWaveUnlocked) {
                player.catWaveUnlocked = true;
                catWaveUI.classList.remove('hidden');
                showMessage("Learned CAT WAVE! Press 'T' to use!", 3000);
            }
            if (bossFightActive && boss) {
                const healthPercent = (boss.hp / boss.maxHp) * 100;
                bossHealthBarInner.style.width = `${healthPercent}%`;
            }
        }

        function showMessage(text, duration = 2000) {
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            setTimeout(() => { messageBox.style.opacity = '0'; }, duration);
        }

        // --- Game Logic ---
        function gridToWorld(gridX, gridY) {
            const x = (gridX - MAP_SIZE / 2 + 0.5) * TILE_SIZE;
            const z = (gridY - MAP_SIZE / 2 + 0.5) * TILE_SIZE;
            return new THREE.Vector3(x, 0, z);
        }

        function movePlayer(dx, dy) {
            if (player.isMoving || player.isAttacking || gameOver) return;
            const newX = player.gridX + dx;
            const newY = player.gridY + dy;
            if (newX >= 0 && newX < MAP_SIZE && newY >= 0 && newY < MAP_SIZE) {
                player.isMoving = true;
                player.gridX = newX;
                player.gridY = newY;
                player.startPosition.copy(player.mesh.position);
                player.targetPosition.copy(gridToWorld(newX, newY));
                player.moveProgress = 0;
            }
        }
        
        // --- Player Attacks ---
        function salmonBladeAttack() { if (!player.isAttacking && !gameOver) performAoEAttack('salmon'); }
        function pawsOfFuryAttack() { if (!player.isAttacking && !gameOver && player.pawsOfFuryUnlocked) performAoEAttack('fury'); }
        
        function catWaveAttack() {
            if (player.isAttacking || gameOver || !player.catWaveUnlocked) return;
            if (bossFightActive) { showMessage("Cat Wave is ineffective against the Boss!", 2500); return; }
            if (enemies.length === 0) { showMessage("No enemies to use Cat Wave on!", 2000); return; }
            
            player.isAttacking = true;
            createExplosionEffect(player.mesh.position);
            const enemiesToAttack = [...enemies];
            handleEnemyDefeat(enemiesToAttack, enemiesToAttack.length);
            showMessage("CAT WAVE! All enemies obliterated!", 3000);
            setTimeout(() => { player.isAttacking = false; }, 1500);
        }

        async function tauntBoss() {
            if (player.isAttacking || gameOver || !bossFightActive) return;
            player.isAttacking = true;
            showMessage("Thinking of a clever taunt...", 3000);

            const characterName = player.isEvolved ? "Ultranyan" : "Jibanyan";
            const prompt = `You are ${characterName} from Yo-kai Watch, a heroic, sassy, cat yokai. You are fighting a giant, tough boss dog called the 'Alpha Dog'. Generate a short, witty, and confident taunt (one sentence) to say to the boss.`;
            
            try {
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiKey = "";
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const text = result.candidates[0].content.parts[0].text;
                    showMessage(`"${text.replace(/"/g, '')}"`, 4000);
                } else {
                    showMessage("My Paws of Fury are way better than your bark!", 4000);
                }
            } catch (error) {
                console.error("Gemini API error:", error);
                showMessage("You're no match for a cat with spirit!", 4000);
            } finally {
                setTimeout(() => { player.isAttacking = false; }, 1000);
            }
        }

        function performAoEAttack(type) {
            if(player.isMoving || player.isAttacking) return;
            
            let totalDamage, message;
            
            if (type === 'salmon') {
                player.isAttacking = true;
                totalDamage = player.attack + 1000;
                message = 'Smoked Salmon Blade!';
                const attackRadius = TILE_SIZE * 1.5;
                
                const swordGeo = new THREE.BoxGeometry(2, 30, 1);
                const hiltGeo = new THREE.BoxGeometry(5, 5, 2);
                const swordMat = new THREE.MeshStandardMaterial({ color: 0xf687b3, emissive: 0xff69b4, metalness: 0.2, roughness: 0.3, transparent: true });
                
                const sword = new THREE.Mesh(swordGeo, swordMat);
                const hilt = new THREE.Mesh(hiltGeo, swordMat);
                sword.add(hilt);
                hilt.position.y = -14;
                
                sword.position.set(0, 15, 5);
                player.mesh.add(sword);

                activeEffects.push({
                    mesh: sword,
                    startTime: Date.now(),
                    duration: 1200,
                    type: 'giantSwordSlam',
                    radius: attackRadius,
                    slammed: false,
                    dealDamage: () => {
                        let hitMessage = '';
                        let enemiesToAttack = [];
                        if (bossFightActive && boss) {
                            if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) enemiesToAttack.push(boss);
                        } else {
                            enemiesToAttack = enemies.filter(e => player.mesh.position.distanceTo(e.mesh.position) < attackRadius);
                        }

                        if (enemiesToAttack.length > 0) {
                            if (bossFightActive) {
                                boss.hp -= totalDamage;
                                if (boss.hp < 0) boss.hp = 0;
                                hitMessage = ` Hit the BOSS for ${totalDamage} DMG!`;
                                updateStatsUI();
                                if (boss.hp <= 0) endGame(true);
                            } else {
                                let enemiesDefeatedCount = 0;
                                hitMessage = ' Hit:';
                                enemiesToAttack.forEach(enemy => {
                                    enemy.hp -= totalDamage;
                                    if (enemy.hp <= 0) enemiesDefeatedCount++;
                                });
                                handleEnemyDefeat(enemiesToAttack, enemiesDefeatedCount);
                            }
                        } else {
                             message += ' ...but it hit nothing!';
                        }
                        showMessage(message + hitMessage, 3500);
                    }
                });
                setTimeout(() => { player.isAttacking = false; }, 1200);

            } else { // fury
                player.isAttacking = true;
                totalDamage = Math.floor(player.attack / 2) * 3;
                message = player.isEvolved ? 'Glitch Wave!' : 'Paws of Fury!';

                let hitMessage = '';
                let enemiesToAttack = [];
                const attackRadius = player.isEvolved ? MAP_DIM : TILE_SIZE * 1.5;

                if (bossFightActive && boss) {
                    if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) {
                       enemiesToAttack.push(boss);
                    }
                } else {
                    enemiesToAttack = enemies.filter(e => player.mesh.position.distanceTo(e.mesh.position) < attackRadius);
                }

                enemiesToAttack.forEach(enemy => {
                    for (let i = 0; i < 5; i++) {
                        createJibanyanPawsEffect(enemy.mesh.position, i * 60);
                    }
                });

                if (enemiesToAttack.length > 0) {
                    if (bossFightActive) {
                        boss.hp -= totalDamage;
                        if (boss.hp < 0) boss.hp = 0;
                        hitMessage = ` Hit the BOSS for ${totalDamage} DMG!`;
                        updateStatsUI();
                        if (boss.hp <= 0) endGame(true);
                    } else {
                        let enemiesDefeatedCount = 0;
                        hitMessage = ' Hit:';
                        enemiesToAttack.forEach(enemy => {
                            enemy.hp -= totalDamage;
                            if (enemy.hp <= 0) enemiesDefeatedCount++;
                        });
                        handleEnemyDefeat(enemiesToAttack, enemiesDefeatedCount);
                    }
                } else {
                     message += ' ...but it hit nothing!';
                }
                showMessage(message + hitMessage, 3500);
                setTimeout(() => { player.isAttacking = false; }, 600);
            }
        }

        // --- Attack Visuals ---
        function createShockwaveEffect(position, color, maxRadius, duration) {
            const geometry = new THREE.RingGeometry(maxRadius * 0.95, maxRadius, 64);
            const material = new THREE.MeshBasicMaterial({ color, side: THREE.DoubleSide, transparent: true });
            const shockwave = new THREE.Mesh(geometry, material);
            shockwave.position.copy(position);
            shockwave.position.y += 0.1;
            shockwave.rotation.x = -Math.PI / 2;
            shockwave.scale.set(0.01, 0.01, 0.01);
            scene.add(shockwave);
            activeEffects.push({ mesh: shockwave, startTime: Date.now(), duration: duration * 1000, type: 'shockwave' });
        }
        
        function createJibanyanPawsEffect(targetPosition, delay) {
            const pawGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const pawMat = new THREE.MeshStandardMaterial({
                color: 0xadd8e6,
                emissive: 0x87cefa,
                transparent: true,
                opacity: 0.9
            });
            const paw = new THREE.Mesh(pawGeo, pawMat);

            const startPos = player.mesh.position.clone().add(new THREE.Vector3(
                (Math.random() - 0.5) * 5,
                2,
                (Math.random() - 0.5) * 5
            ));
            paw.position.copy(startPos);

            scene.add(paw);
            activeEffects.push({
                mesh: paw,
                startTime: Date.now() + delay,
                duration: 400,
                type: 'jibanyanPaw',
                startPosition: startPos,
                targetPosition: targetPosition.clone().add(new THREE.Vector3(0, 3, 0))
            });
        }

        function createExplosionEffect(position) {
            const particleCount = 100;
            const particleMat = new THREE.MeshStandardMaterial({
                color: 0xd9534f,
                transparent: true,
                opacity: 1.0
            });

            for (let i = 0; i < particleCount; i++) {
                const particleGeo = new THREE.BoxGeometry(1, 1, 1);
                const particle = new THREE.Mesh(particleGeo, particleMat.clone());
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 50,
                    (Math.random()) * 50,
                    (Math.random() - 0.5) * 50
                );
                scene.add(particle);
                activeEffects.push({
                    mesh: particle,
                    startTime: Date.now(),
                    duration: 1000 + Math.random() * 500,
                    type: 'explosionParticle',
                    velocity: velocity
                });
            }
        }

        function createDogWaveEffect() {
            const waveCount = 5;
            const waveSpeed = 80;
            const direction = new THREE.Vector3().subVectors(player.mesh.position, boss.mesh.position).normalize();
            const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);

            for (let i = 0; i < waveCount; i++) {
                const offset = (i - Math.floor(waveCount / 2)) * TILE_SIZE * 0.8;
                const startPos = new THREE.Vector3()
                    .copy(boss.mesh.position)
                    .add(perpendicular.clone().multiplyScalar(offset))
                    .sub(direction.clone().multiplyScalar(TILE_SIZE));

                const dogModel = createDogModel(true);
                dogModel.position.copy(startPos);
                dogModel.lookAt(player.mesh.position);
                scene.add(dogModel);

                activeEffects.push({
                    mesh: dogModel,
                    startTime: Date.now(),
                    duration: 2000,
                    type: 'dogWave',
                    velocity: direction.clone().multiplyScalar(waveSpeed)
                });
            }
        }

        // --- Model Creation ---
        function createDogModel(isShadow = false) {
            const group = new THREE.Group();
            const dogMat = new THREE.MeshStandardMaterial({ 
                color: isShadow ? 0x444444 : 0xcd853f, 
                roughness: 0.7,
                transparent: isShadow,
                opacity: isShadow ? 0.7 : 1.0
            });

            const bodyGeo = new THREE.CapsuleGeometry(2, 3, 4, 16);
            const body = new THREE.Mesh(bodyGeo, dogMat);
            body.position.y = 3.5;
            group.add(body);

            const snoutGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const snout = new THREE.Mesh(snoutGeo, dogMat);
            snout.position.set(0, 3.5, 2);
            group.add(snout);

            const earGeo = new THREE.BoxGeometry(0.5, 2, 1);
            const earL = new THREE.Mesh(earGeo, dogMat);
            earL.position.set(-2, 5, 0.5);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, dogMat);
            earR.position.set(2, 5, 0.5);
            group.add(earR);

            const tailGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);
            const tail = new THREE.Mesh(tailGeo, dogMat);
            tail.position.set(0, 3, -2);
            tail.rotation.x = Math.PI / 4;
            group.add(tail);

            return group;
        }

        // --- Combat & Enemy Logic ---
        function handleEnemyDefeat(attackedEnemies, count) {
            const oldKillCount = player.killCount;
            attackedEnemies.filter(e => e.hp <= 0).forEach(deadEnemy => {
                const index = enemies.findIndex(e => e.id === deadEnemy.id);
                if (index > -1) {
                    scene.remove(deadEnemy.mesh);
                    enemies.splice(index, 1);
                }
            });

            if (count > 0) {
                const oldLevel = player.level;
                player.level += count;
                player.killCount += count;
                
                checkUnlocks(oldLevel);

                player.updateStats();
                updateStatsUI();
            }
            if (Math.floor(player.killCount / KILLS_PER_RANK) > Math.floor(oldKillCount / KILLS_PER_RANK)) {
                if (!["Legendary", "Legendary VIP", "UltiMeow"].includes(player.rank)) {
                    rankUp(Math.floor(player.killCount / KILLS_PER_RANK));
                }
            }
            if (count > 0 && !bossFightActive) {
                spawnEnemies(count);
            }
        }
        
        function rankUp(newRankIndex) {
            if (newRankIndex < RANK_ORDER.length) {
                player.rank = RANK_ORDER[newRankIndex];
                showMessage(`Rank Up! You are now Rank ${player.rank}!`, 3000);
                if (player.rank === 'S' && !player.aura) {
                    const auraLight = new THREE.PointLight(0xff0000, 3, 30);
                    auraLight.position.y = 5;
                    player.mesh.add(auraLight);
                    player.aura = auraLight;
                }
                updateStatsUI();
            }
        }

        function checkUnlocks(oldLevel) {
            if (player.level >= 500 && oldLevel < 500) {
                player.rank = "UltiMeow";
                player.baseAttack += 9999999999999999999999999999;
                player.baseHp += 99999;
                showMessage("RANK UP! ULTIMEOW! ATK + ??? | HP +99,999!", 5000);
            } else if (player.level >= 300 && oldLevel < 300) {
                player.rank = "Legendary VIP";
                player.baseAttack += 10000000;
                showMessage("RANK UP! LEGENDARY VIP! ATK +10,000,000!", 4000);
            } else if (player.level >= 100 && oldLevel < 100) {
                player.rank = "Legendary";
                player.baseAttack += 5000;
                showMessage("RANK UP! LEGENDARY! ATK +5,000!", 4000);
            }
            
            if (player.level >= 50 && oldLevel < 50) {
                evolvePlayer();
            }
        }

        function evolvePlayer() {
            if (player.isEvolved) return;
            player.isEvolved = true;
            showMessage("What?! Sprigatitonyan is evolving!", 4000);

            player.name = "Ultranyan";
            player.materials.body.color.set(0x4287f5); // Blue
            player.materials.paw.color.set(0x000000); // Black
            player.materials.eye.color.set(0x34d399); // Green
            player.materials.nick.color.set(0x2a5a9e); // Darker blue for nick
            pawsOfFuryUI.textContent = "A: Glitch Wave";
            
            player.baseHp += 1000;
            player.baseAttack += 1000;
            showMessage("Stats greatly increased!", 3000);

            const flashLight = new THREE.PointLight(0xffffff, 10, 100);
            flashLight.position.copy(player.mesh.position);
            scene.add(flashLight);
            activeEffects.push({
                mesh: flashLight,
                startTime: Date.now(),
                duration: 1500,
                type: 'evolutionFlash'
            });
        }

        function spawnEnemies(count) {
            const occupied = new Set(enemies.map(e => `${e.gridX},${e.gridY}`));
            occupied.add(`${player.gridX},${player.gridY}`);

            for (let i = 0; i < count; i++) {
                if (enemies.length >= BOSS_TRIGGER_COUNT) break;
                let gridX, gridY, attempts = 0;
                do {
                    gridX = Math.floor(Math.random() * MAP_SIZE);
                    gridY = Math.floor(Math.random() * MAP_SIZE);
                    attempts++;
                } while (occupied.has(`${gridX},${gridY}`) && attempts < 50);

                if (attempts < 50) {
                    const id = `enemy-${nextEnemyId++}`;
                    const enemy = { id, hp: 2600, attack: 100, gridX, gridY };
                    
                    enemy.mesh = createDogModel();
                    const pos = gridToWorld(gridX, gridY);
                    enemy.mesh.position.set(pos.x, 0, pos.z);
                    scene.add(enemy.mesh);
                    enemies.push(enemy);
                    occupied.add(`${gridX},${gridY}`);
                }
            }
            if (!bossFightActive && enemies.length >= BOSS_TRIGGER_COUNT) {
                startBossFight();
            }
        }
        
        // --- Boss Logic ---
        function startBossFight() {
            bossFightActive = true;
            showMessage("The horde vanishes... A BOSS appears!", 4000);
            
            [...enemies].forEach(enemy => scene.remove(enemy.mesh));
            enemies.length = 0;

            bossHealthBar.style.display = 'block';
            tauntUI.classList.remove('hidden');
            instructionsElement.textContent += " | G: Taunt";
            playBossMusic();

            spawnBoss();
            updateStatsUI();
            bossAttackInterval = setInterval(bossAttack, 4000);
        }

        function spawnBoss() {
            let gridX, gridY;
            do {
                gridX = Math.floor(Math.random() * MAP_SIZE);
                gridY = Math.floor(Math.random() * MAP_SIZE);
            } while (gridX === player.gridX && gridY === player.gridY);
            
            let bossMaxHp = 10000;
            if (player.rank === "UltiMeow") {
                bossMaxHp = 1000000000000000000000000000;
                showMessage("The Alpha Dog is empowered by your UltiMeow rank!", 4000);
            }
            boss = { maxHp: bossMaxHp, hp: bossMaxHp, attack: 50, gridX, gridY };
            
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
            
            const geo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            const body = new THREE.Mesh(geo, mat);
            group.add(body);
            
            const eyeGeo = new THREE.BoxGeometry(2, 2, 1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-2.5, 2.5, 5.1);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(2.5, 2.5, 5.1);
            group.add(eyeR);

            const snoutGeo = new THREE.BoxGeometry(4, 3, 3);
            const snout = new THREE.Mesh(snoutGeo, mat);
            snout.position.set(0, -2, 6);
            group.add(snout);

            const earGeo = new THREE.BoxGeometry(2, 4, 2);
            const earL = new THREE.Mesh(earGeo, mat);
            earL.position.set(-4, 6, 0);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, mat);
            earR.position.set(4, 6, 0);
            group.add(earR);

            boss.mesh = group;
            const pos = gridToWorld(gridX, gridY);
            boss.mesh.position.set(pos.x, TILE_SIZE / 2, pos.z);
            scene.add(boss.mesh);
        }

        function bossAttack() {
            if (gameOver || !boss) return;
            showMessage("Boss uses Assemble the Pack!", 2000);
            createDogWaveEffect();
            
            setTimeout(() => {
                const attackRadius = TILE_SIZE * 2.5;
                if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) {
                    player.hp -= boss.attack;
                    if (player.hp < 0) player.hp = 0;
                    updateStatsUI();
                    showMessage(`The pack overruns you! -${boss.attack} HP`, 2000);
                    if (player.hp <= 0) endGame(false);
                }
            }, 1000);
        }

        // --- Game State & Animation ---
        function endGame(didWin) {
            gameOver = true;
            clearInterval(bossAttackInterval);
            stopAllMusic();
            if (didWin) {
                winMessageElement.style.display = 'block';
                activeEffects.push({ mesh: boss.mesh, startTime: Date.now(), duration: 1000, type: 'shrink' });
                
                const synth = new Tone.Synth().toDestination();
                const now = Tone.now();
                const notes = ["C5", "E5", "G5", "C6", "G5", "E5", "C5"];
                notes.forEach((note, i) => {
                    synth.triggerAttackRelease(note, "8n", now + i * 0.15);
                });
            } else {
                showMessage("Game Over!", 5000);
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const now = Date.now();

            if (player.isMoving) {
                player.moveProgress += delta * 4;
                const easedProgress = 1 - Math.pow(1 - player.moveProgress, 3);
                
                player.mesh.position.lerpVectors(player.startPosition, player.targetPosition, easedProgress);
                player.mesh.position.y = player.startPosition.y + Math.sin(Math.min(player.moveProgress, 1) * Math.PI) * 5;

                if (player.moveProgress >= 1) {
                    player.isMoving = false;
                    player.moveProgress = 0;
                    player.mesh.position.copy(player.targetPosition);
                    player.mesh.position.y = 0;
                    
                    if (!bossFightActive) {
                        const enemyOnTile = enemies.find(e => e.gridX === player.gridX && e.gridY === player.gridY);
                        if (enemyOnTile) {
                            player.hp -= enemyOnTile.attack;
                            if (player.hp < 0) player.hp = 0;
                            updateStatsUI();
                            showMessage(`Landed on a Dog! Ouch! -${enemyOnTile.attack} HP`, 2000);
                            if (player.hp <= 0) endGame(false);
                        }
                    }
                }
            }
            
            for (let i = activeEffects.length - 1; i >= 0; i--) {
                const effect = activeEffects[i];
                const age = now - effect.startTime;
                let progress = age / effect.duration;
                if (progress < 0) continue;
                if (progress > 1) progress = 1;

                if (effect.type === 'giantSwordSlam') {
                    const sword = effect.mesh;
                    const playerMesh = player.mesh;
                    if (progress < 0.4) {
                        const phaseProgress = progress / 0.4;
                        playerMesh.rotation.x = -THREE.MathUtils.lerp(0, Math.PI / 3, phaseProgress);
                        playerMesh.position.y = THREE.MathUtils.lerp(0, 5, phaseProgress);
                    } else if (progress < 0.5) {
                        if (!effect.slammed) {
                            createShockwaveEffect(playerMesh.position, 0xf687b3, effect.radius * 2, 0.4);
                            effect.dealDamage();
                            effect.slammed = true;
                        }
                        const phaseProgress = (progress - 0.4) / 0.1;
                        playerMesh.rotation.x = -THREE.MathUtils.lerp(Math.PI / 3, 0, phaseProgress);
                        playerMesh.position.y = THREE.MathUtils.lerp(5, 0, phaseProgress);
                    } else {
                        const phaseProgress = (progress - 0.5) / 0.5;
                        sword.material.opacity = 1.0 - phaseProgress;
                    }
                    if (progress >= 1) {
                        playerMesh.rotation.set(0,0,0);
                        playerMesh.remove(sword);
                    }
                } else if (effect.type === 'jibanyanPaw') {
                    effect.mesh.position.lerpVectors(effect.startPosition, effect.targetPosition, progress);
                    effect.mesh.material.opacity = 1.0 - progress;
                } else if (effect.type === 'explosionParticle') {
                    const gravity = 20.0;
                    effect.velocity.y -= gravity * delta;
                    effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));
                    effect.mesh.material.opacity = 1.0 - progress;
                } else if (effect.type === 'dogWave') {
                    effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));
                    effect.mesh.traverse(child => {
                        if (child.isMesh) child.material.opacity = 1.0 - progress;
                    });
                } else if (effect.type === 'shrink') {
                    const scale = 1.0 - progress;
                    effect.mesh.scale.set(scale, scale, scale);
                } else if (effect.type === 'evolutionFlash') {
                    effect.mesh.intensity = (1.0 - Math.abs(progress - 0.5) * 2) * 20;
                }

                if (progress >= 1) {
                    scene.remove(effect.mesh);
                    activeEffects.splice(i, 1);
                }
            }

            if (player.aura) {
                player.aura.intensity = 2 + Math.sin(now * 0.005) * 1.5;
            }

            const targetCameraPosition = new THREE.Vector3().copy(player.mesh.position).add(cameraOffset);
            camera.position.lerp(targetCameraPosition, 0.05);
            camera.lookAt(player.mesh.position);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        window.addEventListener('resize', onWindowResize);
        
        const handleKeyDown = (e) => {
            if (!isAudioStarted) {
                Tone.start();
                isAudioStarted = true;
                playAdventureMusic();
            }
            if (gameOver) return;
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
                case 'y': case 'Y': salmonBladeAttack(); break;
                case 'a': case 'A': pawsOfFuryAttack(); break;
                case 't': case 'T': catWaveAttack(); break;
                case 'r': case 'R': catastropheAttack(); break;
                case 'k': case 'K': legendaryBladeAttack(); break;
                case 'g': case 'G': tauntBoss(); break;
            }
        };
        window.addEventListener('keydown', handleKeyDown);

        // --- Music ---
        let adventureMusic = {};
        let bossMusic = {};

        function stopAllMusic() {
            if (adventureMusic.melody) adventureMusic.melody.stop();
            if (adventureMusic.bass) adventureMusic.bass.stop();
            if (bossMusic.melody) bossMusic.melody.stop();
            if (bossMusic.bass) bossMusic.bass.stop();
            Tone.Transport.stop();
            Tone.Transport.cancel();
        }

        function playAdventureMusic() {
            stopAllMusic();
            const melodySynth = new Tone.Synth({ oscillator: { type: "pulse" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.2, release: 0.2 } }).toDestination();
            const bassSynth = new Tone.MonoSynth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            bassSynth.volume.value = -10;

            const melodyNotes = ["C4", "E4", "G4", "A4", "G4", "E4", "C4", null];
            const bassNotes = ["C2", null, "F2", null, "G2", null, "C2", null];

            adventureMusic.melody = new Tone.Sequence((time, note) => {
                if(note) melodySynth.triggerAttackRelease(note, "8n", time);
            }, melodyNotes, "4n").start(0);

            adventureMusic.bass = new Tone.Sequence((time, note) => {
                if(note) bassSynth.triggerAttackRelease(note, "2n", time);
            }, bassNotes, "2n").start(0);

            Tone.Transport.bpm.value = 120;
            Tone.Transport.start();
        }

        function playBossMusic() {
            stopAllMusic();
            const melodySynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.1 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.5, decay: 0.01 } }).toDestination();
            const bassSynth = new Tone.MonoSynth({ oscillator: { type: "fatsquare" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            bassSynth.volume.value = -8;

            const melodyNotes = ["C3", "C#3", "D3", "C#3", "C3", "G#2", "A#2", "G#2"];
            const bassNotes = ["C2", null, "C2", "G#1", "C2", null, "C2", "A#1"];

            bossMusic.melody = new Tone.Sequence((time, note) => {
                if(note) melodySynth.triggerAttackRelease(note, "8n", time);
            }, melodyNotes, "8n").start(0);

            bossMusic.bass = new Tone.Sequence((time, note) => {
                if(note) bassSynth.triggerAttackRelease(note, "4n", time);
            }, bassNotes, "4n").start(0);

            Tone.Transport.bpm.value = 140;
            Tone.Transport.start();
        }

        function init() {
            createPlayer();
            updateStatsUI();
            spawnEnemies(4);
            onWindowResize();
            animate();
        }
        
        init();
    </script>
</body>
</html>
