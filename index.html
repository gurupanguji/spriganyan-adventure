<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sprigatitonyan's Adventure 3D</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body {
            font-family: 'Press Start 2P', cursive;
            background-color: #1a202c;
            color: #a0aec0;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            width: 100vw;
            height: 100vh;
            display: grid;
            grid-template-areas:
                "header header"
                "main sidebar";
            grid-template-columns: 1fr 350px;
            grid-template-rows: auto 1fr;
            gap: 1rem;
            padding: 1rem;
        }
        #canvas-container {
            grid-area: main;
            position: relative;
            min-height: 0;
            border-radius: 12px;
            overflow: hidden;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .stats-panel {
            grid-area: sidebar;
            background-color: #2d3748;
            border: 4px solid #4a5568;
            border-radius: 12px;
            padding: 1.5rem;
            overflow-y: auto;
        }
        .game-header {
            grid-area: header;
            text-align: center;
        }
        .message-box {
            position: fixed; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7); color: white;
            padding: 15px 25px; border-radius: 10px;
            opacity: 0; transition: opacity 0.5s; z-index: 100;
            max-width: 80%; text-align: center;
        }
        .boss-health-bar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 20px;
            background-color: #4a5568;
            border: 2px solid #a0aec0;
            border-radius: 10px;
            z-index: 50;
            display: none;
        }
        .boss-health-bar-inner {
            width: 100%; height: 100%;
            background-color: #c53030;
            border-radius: 8px;
            transition: width 0.5s ease;
        }
        .soultimate-gauge {
            background-color: #4a5568;
            border: 2px solid #a0aec0;
            border-radius: 10px;
            padding: 2px;
            margin-top: 1rem;
        }
        .soultimate-gauge-inner {
            height: 10px;
            background-color: #f6ad55;
            border-radius: 6px;
            width: 0%;
            transition: width 0.5s ease;
        }
        .win-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 10vw;
            font-family: 'Press Start 2P', cursive;
            color: yellow;
            text-shadow: 0 0 10px white, 0 0 20px yellow, 0 0 30px #ffc107;
            z-index: 1001;
            animation: flash 1s infinite;
            display: none;
        }
        @keyframes flash {
            0%, 100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="game-container" style="opacity: 1;">
        <header class="game-header">
            <h1 class="text-xl md:text-3xl font-bold text-white">Sprigatitonyan's Adventure 3D</h1>
            <p id="instructions" class="text-xs md:text-sm mt-2">Arrows: Move | Y: Claws | A: Soultimate | S: Summon | E: Claw Rush | R: Inspirit | G: Taunt | K: Giganta-Blade</p>
        </header>

        <main id="canvas-container">
            <div id="boss-health-bar"><div id="boss-health-bar-inner"></div></div>
            <canvas id="game-canvas"></canvas>
        </main>

        <aside class="stats-panel">
            <h2 class="text-2xl font-bold text-white mb-6 border-b-2 border-gray-600 pb-2">STATS</h2>
            <div id="player-stats" class="space-y-4 text-sm">
                <div><span class="font-bold text-green-400">Name:</span><span id="stat-name" class="float-right text-white"></span></div>
                <div><span class="font-bold text-red-400">HP:</span><span id="stat-hp" class="float-right text-white"></span></div>
                <div><span class="font-bold text-yellow-400">Attack:</span><span id="stat-attack" class="float-right text-white"></span></div>
                <div><span class="font-bold text-blue-400">Level:</span><span id="stat-level" class="float-right text-white"></span></div>
                <div><span class="font-bold text-purple-400">Rank:</span><span id="stat-rank" class="float-right text-white"></span></div>
                <div><span class="font-bold text-cyan-400">Medals:</span><span id="stat-medals" class="float-right text-white"></span></div>
                <div><span class="font-bold text-teal-400">Yo-kai Watch:</span><span id="stat-watch" class="float-right text-white"></span></div>
                
                <div class="pt-4">
                    <div class="font-bold text-orange-400 mb-1">Soultimate</div>
                    <div class="soultimate-gauge"><div id="soultimate-gauge-inner" class="soultimate-gauge-inner"></div></div>
                </div>

                <div class="border-t border-gray-600 pt-4 mt-4">
                    <div class="font-bold text-pink-400">Special Attacks</div>
                    <div id="attack-list" class="text-xs mt-2 space-y-1">
                         <div>Y: Sharp Claws</div>
                         <div id="paws-of-fury-ui" class="hidden">A: Paws of Fury (Soultimate)</div>
                         <div id="cat-wave-ui" class="hidden">T: Cat Wave</div>
                         <div id="claw-rush-ui" class="hidden">E: Claw Rush</div>
                         <div id="giganta-blade-ui" class="hidden">K: Giganta-Blade</div>
                         <div id="inspirit-ui" class="hidden">R: Inspirit</div>
                         <div id="summon-ui">S: Summon Ally</div>
                         <div id="taunt-ui" class="hidden">G: âœ¨ Taunt Boss</div>
                    </div>
                </div>
            </div>
        </aside>
    </div>

    <div id="win-message" class="win-message">YOU WIN!!!</div>
    <div id="message-box" class="message-box"></div>

    <script type="importmap">
        { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.165.0/build/three.module.js" } }
    </script>
    <script type="module">
        import * as THREE from 'three';

        // --- Game Configuration ---
        const MAP_SIZE = 8;
        const TILE_SIZE = 10;
        const MAP_DIM = MAP_SIZE * TILE_SIZE;
        const KILLS_PER_RANK = 10;
        const RANK_ORDER = ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'S'];
        const ALLY_LIFETIME = 30000; // 30 seconds
        let gameOver = false;
        let bossFightActive = false;
        let bossAttackInterval = null;
        let isAudioStarted = false;

        // --- Game State ---
        const player = {
            name: 'Sprigatitonyan', level: 1, baseHp: 1000, baseAttack: 300, hp: 1000, attack: 300,
            gridX: 4, gridY: 4, isMoving: false, isAttacking: false, 
            pawsOfFuryUnlocked: false, catWaveUnlocked: false, inspiritUnlocked: false, clawRushUnlocked: false, gigantaBladeUnlocked: false,
            soultimateGauge: 0, maxSoultimate: 100,
            yokaiMedals: 0,
            hasYokaiWatch: false,
            killCount: 0, rank: 'G', mesh: null, aura: null,
            isEvolved: false, materials: {},
            targetPosition: new THREE.Vector3(),
            startPosition: new THREE.Vector3(),
            moveProgress: 0,
            updateStats: function() {
                const oldMaxHp = this.baseHp + (this.level - 2) * 10;
                const newMaxHp = this.baseHp + (this.level - 1) * 10;
                this.hp += newMaxHp - oldMaxHp;
                if (this.hp > newMaxHp) this.hp = newMaxHp;
                this.attack = this.baseAttack + (this.level - 1) * 30;
            },
            addSoultimate: function(amount) {
                this.soultimateGauge += amount;
                if (this.soultimateGauge > this.maxSoultimate) {
                    this.soultimateGauge = this.maxSoultimate;
                }
                updateStatsUI();
            }
        };
        const enemies = [];
        const alliedYoKai = [];
        let nextEnemyId = 0;
        let nextAllyId = 0;
        let boss = null;
        const activeEffects = [];

        // --- DOM Elements ---
        const messageBox = document.getElementById('message-box');
        const pawsOfFuryUI = document.getElementById('paws-of-fury-ui');
        const catWaveUI = document.getElementById('cat-wave-ui');
        const inspiritUI = document.getElementById('inspirit-ui');
        const clawRushUI = document.getElementById('claw-rush-ui');
        const gigantaBladeUI = document.getElementById('giganta-blade-ui');
        const tauntUI = document.getElementById('taunt-ui');
        const instructionsElement = document.getElementById('instructions');
        const bossHealthBar = document.getElementById('boss-health-bar');
        const bossHealthBarInner = document.getElementById('boss-health-bar-inner');
        const winMessageElement = document.getElementById('win-message');
        const soultimateGaugeInner = document.getElementById('soultimate-gauge-inner');

        // --- Three.js Setup ---
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87ceeb);
        const canvas = document.getElementById('game-canvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        const camera = new THREE.PerspectiveCamera(60, canvas.clientWidth / canvas.clientHeight, 0.1, 1000);
        const cameraOffset = new THREE.Vector3(0, 80, 60);
        camera.position.copy(cameraOffset);
        
        // --- Lighting ---
        scene.add(new THREE.AmbientLight(0xaaaaaa));
        const dirLight = new THREE.DirectionalLight(0xffffff, 2);
        dirLight.position.set(20, 50, 30);
        scene.add(dirLight);

        // --- World Creation ---
        const plane = new THREE.Mesh(
            new THREE.PlaneGeometry(MAP_DIM + 20, MAP_DIM + 20),
            new THREE.MeshStandardMaterial({ color: 0x66CDAA })
        );
        plane.rotation.x = -Math.PI / 2;
        scene.add(plane);
        
        // --- Player Creation (Jibanyan Style) ---
        function createPlayer() {
            const group = new THREE.Group();
            player.materials.body = new THREE.MeshStandardMaterial({ color: 0xd9534f, roughness: 0.6 });
            player.materials.belly = new THREE.MeshStandardMaterial({ color: 0xffe066, roughness: 0.7 });
            player.materials.flame = new THREE.MeshStandardMaterial({ color: 0xffa500, emissive: 0xffa500 });
            player.materials.paw = new THREE.MeshStandardMaterial({ color: 0xffffff });
            player.materials.eye = new THREE.MeshBasicMaterial({ color: 0x000000 });
            player.materials.nose = new THREE.MeshStandardMaterial({ color: 0xffc0cb });
            player.materials.collar = new THREE.MeshStandardMaterial({color: 0x5bc0de});
            player.materials.bell = new THREE.MeshStandardMaterial({color: 0xffd700, metalness: 0.5});
            player.materials.nick = new THREE.MeshStandardMaterial({color: 0x8c3835});

            const bodyGeo = new THREE.CapsuleGeometry(3, 2, 4, 16);
            const body = new THREE.Mesh(bodyGeo, player.materials.body);
            body.position.y = 2.5;
            group.add(body);

            const headGeo = new THREE.SphereGeometry(3.5, 16, 16);
            const head = new THREE.Mesh(headGeo, player.materials.body);
            head.position.y = 6;
            group.add(head);

            const muzzleGeo = new THREE.SphereGeometry(2, 16, 16);
            const muzzle = new THREE.Mesh(muzzleGeo, player.materials.paw);
            muzzle.position.set(0, 5.5, 2);
            muzzle.scale.y = 0.8;
            group.add(muzzle);

            const eyeGeo = new THREE.CircleGeometry(0.8, 16);
            const eyeL = new THREE.Mesh(eyeGeo, player.materials.eye);
            eyeL.position.set(-1.5, 6.5, 3.3);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, player.materials.eye);
            eyeR.position.set(1.5, 6.5, 3.3);
            group.add(eyeR);

            const noseGeo = new THREE.ConeGeometry(0.5, 0.7, 4);
            const nose = new THREE.Mesh(noseGeo, player.materials.nose);
            nose.position.set(0, 6, 3.8);
            nose.rotation.x = Math.PI / 2;
            group.add(nose);

            const armGeo = new THREE.CylinderGeometry(0.8, 0.6, 2.5, 8);
            const pawGeo = new THREE.SphereGeometry(1.2, 8, 8);

            const armL = new THREE.Mesh(armGeo, player.materials.body);
            armL.name = "armL";
            armL.position.set(-3.5, 3.5, 0);
            armL.rotation.z = Math.PI / 2;
            group.add(armL);
            const pawL = new THREE.Mesh(pawGeo, player.materials.paw);
            pawL.name = "pawL";
            pawL.position.set(-4.5, 3.5, 0);
            group.add(pawL);

            const armR = new THREE.Mesh(armGeo, player.materials.body);
            armR.name = "armR";
            armR.position.set(3.5, 3.5, 0);
            armR.rotation.z = -Math.PI / 2;
            group.add(armR);
            const pawR = new THREE.Mesh(pawGeo, player.materials.paw);
            pawR.name = "pawR";
            pawR.position.set(4.5, 3.5, 0);
            group.add(pawR);

            const bellyGeo = new THREE.CylinderGeometry(3.1, 3.1, 2.5, 16);
            const belly = new THREE.Mesh(bellyGeo, player.materials.belly);
            belly.position.y = 2.5;
            group.add(belly);

            const earGeo = new THREE.ConeGeometry(1.8, 4, 4);
            const earL = new THREE.Mesh(earGeo, player.materials.body);
            earL.position.set(-2.5, 9, 0);
            earL.rotation.z = -Math.PI / 10;
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, player.materials.body);
            earR.position.set(2.5, 9, 0);
            earR.rotation.z = Math.PI / 10;
            
            const nickL = new THREE.Mesh(new THREE.SphereGeometry(0.5), player.materials.nick);
            nickL.position.set(-3.5, 9.5, 0.5);
            group.add(nickL);

            const collar = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.3, 8, 32), player.materials.collar);
            collar.position.y = 4.5;
            collar.rotation.x = Math.PI / 2;
            group.add(collar);
            const bell = new THREE.Mesh(new THREE.SphereGeometry(0.6), player.materials.bell);
            bell.position.set(0, 4.5, 3.5);
            group.add(bell);

            for (let i = -1; i <= 1; i += 2) {
                const tailGroup = new THREE.Group();
                const tailCurve = new THREE.CatmullRomCurve3([
                    new THREE.Vector3(0, 2, -2.5),
                    new THREE.Vector3(i * 2, 3, -4),
                    new THREE.Vector3(i * 3, 4, -6)
                ]);
                const tailGeo = new THREE.TubeGeometry(tailCurve, 20, 0.4, 8, false);
                const tail = new THREE.Mesh(tailGeo, player.materials.body);
                tailGroup.add(tail);

                const flame = new THREE.Mesh(new THREE.ConeGeometry(1, 2, 8), player.materials.flame);
                flame.position.copy(tailCurve.getPoint(1));
                tailGroup.add(flame);
                group.add(tailGroup);
            }

            player.mesh = group;
            const startPos = gridToWorld(player.gridX, player.gridY);
            player.mesh.position.copy(startPos);
            player.targetPosition.copy(startPos);
            player.startPosition.copy(startPos);
            scene.add(group);
        }

        // --- UI Update ---
        function updateStatsUI() {
            document.getElementById('stat-name').textContent = player.name;
            document.getElementById('stat-hp').textContent = player.hp;
            document.getElementById('stat-attack').textContent = player.attack;
            document.getElementById('stat-level').textContent = player.level;
            document.getElementById('stat-rank').textContent = player.rank;
            document.getElementById('stat-medals').textContent = player.yokaiMedals;
            document.getElementById('stat-watch').textContent = player.hasYokaiWatch ? 'YES' : 'NO';
            
            const soultimatePercent = (player.soultimateGauge / player.maxSoultimate) * 100;
            soultimateGaugeInner.style.width = `${soultimatePercent}%`;

            if (player.level >= 2 && !player.pawsOfFuryUnlocked) {
                player.pawsOfFuryUnlocked = true;
                pawsOfFuryUI.classList.remove('hidden');
                showMessage("Learned Paws of Fury! Press 'A' to use!", 3000);
            }
            if (player.level >= 5 && !player.inspiritUnlocked) {
                player.inspiritUnlocked = true;
                inspiritUI.classList.remove('hidden');
                showMessage("Learned Inspirit! Press 'R' to use!", 3000);
            }
             if (player.level >= 10 && !player.clawRushUnlocked) {
                player.clawRushUnlocked = true;
                clawRushUI.classList.remove('hidden');
                showMessage("Learned Claw Rush! Press 'E' to use!", 3000);
            }
             if (player.level >= 15 && !player.gigantaBladeUnlocked) {
                player.gigantaBladeUnlocked = true;
                gigantaBladeUI.classList.remove('hidden');
                showMessage("Learned Giganta-Blade! Press 'K' to use!", 3000);
            }
            if (player.level >= 30 && !player.catWaveUnlocked) {
                player.catWaveUnlocked = true;
                catWaveUI.classList.remove('hidden');
                showMessage("Learned CAT WAVE! Press 'T' to use!", 3000);
            }
            if (bossFightActive && boss) {
                const healthPercent = (boss.hp / boss.maxHp) * 100;
                bossHealthBarInner.style.width = `${healthPercent}%`;
            }
        }

        function showMessage(text, duration = 2000) {
            messageBox.textContent = text;
            messageBox.style.opacity = '1';
            setTimeout(() => { messageBox.style.opacity = '0'; }, duration);
        }

        // --- Game Logic ---
        function gridToWorld(gridX, gridY) {
            const x = (gridX - MAP_SIZE / 2 + 0.5) * TILE_SIZE;
            const z = (gridY - MAP_SIZE / 2 + 0.5) * TILE_SIZE;
            return new THREE.Vector3(x, 0, z);
        }

        function movePlayer(dx, dy) {
            if (player.isMoving || player.isAttacking || gameOver) return;
            const newX = player.gridX + dx;
            const newY = player.gridY + dy;
            if (newX >= 0 && newX < MAP_SIZE && newY >= 0 && newY < MAP_SIZE) {
                player.isMoving = true;
                player.gridX = newX;
                player.gridY = newY;
                player.startPosition.copy(player.mesh.position);
                player.targetPosition.copy(gridToWorld(newX, newY));
                player.moveProgress = 0;
            }
        }
        
        // --- Player Attacks ---
        function sharpClawsAttack() { if (!player.isAttacking && !gameOver) performAoEAttack('claws'); }
        function pawsOfFuryAttack() { if (!player.isAttacking && !gameOver && player.pawsOfFuryUnlocked) performAoEAttack('fury'); }
        function clawRushAttack() { if (!player.isAttacking && !gameOver && player.clawRushUnlocked) performAoEAttack('clawRush'); }
        function gigantaBladeAttack() { if (!player.isAttacking && !gameOver && player.gigantaBladeUnlocked) performAoEAttack('gigantaBlade'); }
        
        function catWaveAttack() {
            if (player.isAttacking || gameOver || !player.catWaveUnlocked) return;
            if (bossFightActive) { showMessage("Cat Wave is ineffective against the Boss!", 2500); return; }
            if (enemies.length === 0) { showMessage("No enemies to use Cat Wave on!", 2000); return; }
            
            player.isAttacking = true;
            createExplosionEffect(player.mesh.position);
            const enemiesToAttack = [...enemies];
            handleEnemyDefeat(enemiesToAttack, enemiesToAttack.length);
            showMessage("CAT WAVE! All enemies obliterated!", 3000);
            player.addSoultimate(20);
            setTimeout(() => { player.isAttacking = false; }, 1500);
        }

        function inspiritBoss() {
            if (player.isAttacking || gameOver || !bossFightActive || !player.inspiritUnlocked) return;
            player.isAttacking = true;
            
            if (Math.random() < 0.6) { // 60% chance to succeed
                showMessage("Inspirit successful! Boss attack lowered!", 3000);
                boss.attackModifier = 0.5;
                createAuraEffect(boss.mesh, 0x800080, 'inspirit'); // Purple aura
                setTimeout(() => {
                    if (boss) boss.attackModifier = 1.0;
                    showMessage("Boss is no longer inspirited.", 2000);
                }, 10000); // Lasts 10 seconds
            } else {
                showMessage("Inspirit failed!", 2000);
            }

            setTimeout(() => { player.isAttacking = false; }, 1000);
        }

        async function tauntBoss() {
            if (player.isAttacking || gameOver || !bossFightActive) return;
            player.isAttacking = true;
            showMessage("Thinking of a clever taunt...", 3000);

            const characterName = player.isEvolved ? "Ultranyan" : "Jibanyan";
            const prompt = `You are ${characterName} from Yo-kai Watch, a heroic, sassy, cat yokai. You are fighting a giant, tough boss dog called the 'Alpha Dog'. Generate a short, witty, and confident taunt (one sentence) to say to the boss.`;
            
            try {
                const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
                const payload = { contents: chatHistory };
                const apiKey = ""; // API Key is handled by the environment
                const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;
                
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const result = await response.json();
                
                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts[0]) {
                    const text = result.candidates[0].content.parts[0].text;
                    showMessage(`"${text.replace(/"/g, '')}"`, 4000);
                } else {
                    showMessage("My Paws of Fury are way better than your bark!", 4000);
                }
            } catch (error) {
                console.error("Gemini API error:", error);
                showMessage("You're no match for a cat with spirit!", 4000);
            } finally {
                setTimeout(() => { player.isAttacking = false; }, 1000);
            }
        }

        function performAoEAttack(type) {
            if(player.isMoving || player.isAttacking) return;
            
            let totalDamage, message;
            
            if (type === 'claws') {
                player.isAttacking = true;
                totalDamage = player.attack;
                message = 'Sharp Claws!';
                const attackRadius = TILE_SIZE * 1.5;
                
                for(let i = 0; i < 3; i++) {
                    createSlashEffect(player.mesh.position, i * 100);
                }
                
                let hitMessage = '';
                let enemiesToAttack = [];
                if (bossFightActive && boss) {
                    if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) enemiesToAttack.push(boss);
                } else {
                    enemiesToAttack = enemies.filter(e => player.mesh.position.distanceTo(e.mesh.position) < attackRadius);
                }

                if (enemiesToAttack.length > 0) {
                    player.addSoultimate(10);
                    if (bossFightActive) {
                        boss.hp -= totalDamage;
                        if (boss.hp < 0) boss.hp = 0;
                        hitMessage = ` Hit the BOSS for ${totalDamage} DMG!`;
                        updateStatsUI();
                        if (boss.hp <= 0) endGame(true);
                    } else {
                        let enemiesDefeatedCount = 0;
                        enemiesToAttack.forEach(enemy => {
                            enemy.hp -= totalDamage;
                            if (enemy.hp <= 0) enemiesDefeatedCount++;
                        });
                        handleEnemyDefeat(enemiesToAttack, enemiesDefeatedCount);
                    }
                } else {
                     message += ' ...but it hit nothing!';
                }
                showMessage(message + hitMessage, 2500);
                setTimeout(() => { player.isAttacking = false; }, 600);

            } else if (type === 'fury') {
                if (player.soultimateGauge < player.maxSoultimate) {
                    showMessage("Soultimate not ready!", 2000);
                    return;
                }
                player.isAttacking = true;
                player.soultimateGauge = 0;
                updateStatsUI();

                totalDamage = player.attack * 5;
                message = player.isEvolved ? 'Glitch Wave!' : 'PAWS OF FURY!';

                let hitMessage = '';
                let enemiesToAttack = [];
                const attackRadius = player.isEvolved ? MAP_DIM : TILE_SIZE * 2;

                if (bossFightActive && boss) {
                    if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) {
                       enemiesToAttack.push(boss);
                    }
                } else {
                    enemiesToAttack = enemies.filter(e => player.mesh.position.distanceTo(e.mesh.position) < attackRadius);
                }

                enemiesToAttack.forEach(enemy => {
                    for (let i = 0; i < 15; i++) { // More paws for Soultimate
                        createJibanyanPawsEffect(enemy.mesh.position, i * 30);
                    }
                });

                if (enemiesToAttack.length > 0) {
                    if (bossFightActive) {
                        boss.hp -= totalDamage;
                        if (boss.hp < 0) boss.hp = 0;
                        hitMessage = ` Hit the BOSS for ${totalDamage} DMG!`;
                        updateStatsUI();
                        if (boss.hp <= 0) endGame(true);
                    } else {
                        let enemiesDefeatedCount = 0;
                        enemiesToAttack.forEach(enemy => {
                            enemy.hp -= totalDamage;
                            if (enemy.hp <= 0) enemiesDefeatedCount++;
                        });
                        handleEnemyDefeat(enemiesToAttack, enemiesDefeatedCount);
                    }
                } else {
                     message += ' ...but it hit nothing!';
                }
                showMessage(message + hitMessage, 3500);
                setTimeout(() => { player.isAttacking = false; }, 1000);
            } else if (type === 'clawRush') {
                const attackRadius = TILE_SIZE * 1.5; // Approx 1 tile radius
                let nearestEnemy = null;
                let minDistance = Infinity;
                
                const potentialTargets = bossFightActive ? (boss ? [boss] : []) : enemies;
                potentialTargets.forEach(enemy => {
                    const distance = player.mesh.position.distanceTo(enemy.mesh.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestEnemy = enemy;
                    }
                });

                if (!nearestEnemy || minDistance > attackRadius) {
                    showMessage("No target in range for Claw Rush!", 2000);
                    return;
                }
                
                player.isAttacking = true;
                totalDamage = player.attack * 2.5;
                message = 'Claw Rush!';
                
                createClawRushEffect(nearestEnemy);

                setTimeout(() => {
                    // Check if target is still valid before dealing damage
                    const targetStillExists = bossFightActive ? boss : enemies.find(e => e.id === nearestEnemy.id);
                    if (!targetStillExists) return;

                    createSlashEffect(nearestEnemy.mesh.position, 0); // Visual hit effect
                    if (bossFightActive) {
                        boss.hp -= totalDamage;
                        if (boss.hp < 0) boss.hp = 0;
                        if (boss.hp <= 0) endGame(true);
                    } else {
                        nearestEnemy.hp -= totalDamage;
                        if (nearestEnemy.hp <= 0) handleEnemyDefeat([nearestEnemy], 1);
                    }
                    player.addSoultimate(25);
                    showMessage(`${message} Hit for ${totalDamage} DMG!`, 2500);
                    updateStatsUI();
                }, 800);

                setTimeout(() => { player.isAttacking = false; }, 1200);
            } else if (type === 'gigantaBlade') {
                player.isAttacking = true;
                message = 'Giganta-Blade!';
                const attackRadius = TILE_SIZE * 1.5;

                let enemiesToAttack = [];
                if (bossFightActive && boss) {
                    if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) enemiesToAttack.push(boss);
                } else {
                    enemiesToAttack = enemies.filter(e => player.mesh.position.distanceTo(e.mesh.position) < attackRadius);
                }

                if (enemiesToAttack.length > 0) {
                    const baseDamage = player.attack * 3.5;
                    const totalDamagePerEnemy = baseDamage * enemiesToAttack.length; // Damage scales with number of targets

                    player.addSoultimate(30);
                    
                    const swordSynth = new Tone.Synth({
                        oscillator: { type: 'triangle' },
                        envelope: { attack: 0.005, decay: 0.1, sustain: 0.01, release: 0.1 }
                    }).toDestination();
                    swordSynth.volume.value = -15;
                    
                    let soundDelayCounter = 0; // Counter for unique sound scheduling

                    enemiesToAttack.forEach(target => {
                        for(let i = 0; i < 25; i++) {
                            createSwordEffect(target.mesh.position, i * 25);
                            swordSynth.triggerAttackRelease("A5", "32n", Tone.now() + (soundDelayCounter * 25) / 1000);
                            soundDelayCounter++;
                        }
                    });

                    setTimeout(() => {
                        if (bossFightActive) {
                            boss.hp -= totalDamagePerEnemy;
                            if (boss.hp < 0) boss.hp = 0;
                            showMessage(`${message} Hit the BOSS for ${totalDamagePerEnemy} DMG!`, 2500);
                            updateStatsUI();
                            if (boss.hp <= 0) endGame(true);
                        } else {
                            let enemiesDefeatedCount = 0;
                            enemiesToAttack.forEach(enemy => {
                                enemy.hp -= totalDamagePerEnemy;
                                if (enemy.hp <= 0) enemiesDefeatedCount++;
                            });
                            handleEnemyDefeat(enemiesToAttack, enemiesDefeatedCount);
                            showMessage(`${message} Hit ${enemiesToAttack.length} enemies for ${totalDamagePerEnemy} DMG each!`, 3000);
                        }
                    }, 800);

                } else {
                     message += ' ...but there were no targets!';
                     showMessage(message, 2500);
                }
                
                setTimeout(() => { player.isAttacking = false; }, 1500);
            }
        }

        // --- Attack Visuals ---
        function createSlashEffect(position, delay) {
            const slashGeo = new THREE.TorusGeometry(TILE_SIZE * 0.8, 0.3, 2, 32, Math.PI);
            const slashMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide, transparent: true });
            const slash = new THREE.Mesh(slashGeo, slashMat);
            slash.position.copy(position).add(new THREE.Vector3(0, 4, 0));
            slash.rotation.y = Math.random() * Math.PI * 2;
            slash.rotation.x = (Math.random() - 0.5) * Math.PI;
            scene.add(slash);
            activeEffects.push({
                mesh: slash,
                startTime: Date.now() + delay,
                duration: 300,
                type: 'slash'
            });
        }

        function createClawRushEffect(target) {
            const rushCount = 6;
            const radius = TILE_SIZE * 0.7;
            for (let i = 0; i < rushCount; i++) {
                const angle = (i / rushCount) * Math.PI * 2;
                const startOffset = new THREE.Vector3(Math.cos(angle + Math.PI) * radius, 0, Math.sin(angle + Math.PI) * radius);
                const endOffset = new THREE.Vector3(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
                
                const startPos = target.mesh.position.clone().add(startOffset);
                const endPos = target.mesh.position.clone().add(endOffset);

                const dashGeo = new THREE.BoxGeometry(2, 6, 2);
                const dashMesh = new THREE.Mesh(dashGeo, player.materials.body.clone());
                dashMesh.material.transparent = true;
                
                scene.add(dashMesh);

                activeEffects.push({
                    mesh: dashMesh,
                    startTime: Date.now() + i * 100,
                    duration: 200,
                    type: 'clawRushDash',
                    startPosition: startPos,
                    targetPosition: endPos,
                    target: target
                });
            }
        }
        
        function createSwordEffect(targetPosition, delay) {
            const sword = new THREE.Group();
            const bladeMat = new THREE.MeshStandardMaterial({
                color: 0xc0c0c0, metalness: 0.9, roughness: 0.4,
                emissive: new THREE.Color(Math.random(), Math.random(), Math.random()),
                emissiveIntensity: 0.8
            });
            const hiltMat = new THREE.MeshStandardMaterial({ color: 0x4a2c2a, roughness: 0.8 });
            const guardMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.7, roughness: 0.5 });
            const bladeGeo = new THREE.BoxGeometry(0.4, 4, 0.1);
            const hiltGeo = new THREE.CylinderGeometry(0.2, 0.2, 1, 8);
            const guardGeo = new THREE.BoxGeometry(1, 0.2, 0.2);
            const blade = new THREE.Mesh(bladeGeo, bladeMat);
            const hilt = new THREE.Mesh(hiltGeo, hiltMat);
            const guard = new THREE.Mesh(guardGeo, guardMat);
            blade.position.y = 2;
            hilt.position.y = -0.5;
            sword.add(blade, hilt, guard);
            const startPos = player.mesh.position.clone().add(new THREE.Vector3(0, 4, 0));
            sword.position.copy(startPos);
            sword.lookAt(targetPosition);
            scene.add(sword);
            activeEffects.push({
                mesh: sword, startTime: Date.now() + delay, duration: 400, type: 'sword',
                startPosition: startPos,
                targetPosition: targetPosition.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * 5, 3, (Math.random() - 0.5) * 5
                ))
            });
        }

        function createAuraEffect(targetMesh, color, effectId, duration = 10000) {
            const existingAuraIndex = activeEffects.findIndex(e => e.type === 'aura' && e.effectId === effectId);
            if (existingAuraIndex > -1) {
                scene.remove(activeEffects[existingAuraIndex].mesh);
                activeEffects.splice(existingAuraIndex, 1);
            }

            const auraGeo = new THREE.SphereGeometry(4, 16, 16);
            const auraMat = new THREE.MeshStandardMaterial({
                color: color, transparent: true, opacity: 0.4,
                emissive: color, emissiveIntensity: 2
            });
            const aura = new THREE.Mesh(auraGeo, auraMat);
            aura.position.copy(targetMesh.position);
            scene.add(aura);

            activeEffects.push({
                mesh: aura, target: targetMesh, startTime: Date.now(),
                duration: duration, type: 'aura', effectId: effectId
            });
        }
        
        function createJibanyanPawsEffect(targetPosition, delay) {
            const pawGeo = new THREE.SphereGeometry(1.5, 8, 8);
            const pawMat = new THREE.MeshStandardMaterial({
                color: 0xadd8e6, emissive: 0x87cefa,
                transparent: true, opacity: 0.9
            });
            const paw = new THREE.Mesh(pawGeo, pawMat);

            const startPos = player.mesh.position.clone().add(new THREE.Vector3(
                (Math.random() - 0.5) * 10, 2, (Math.random() - 0.5) * 10
            ));
            paw.position.copy(startPos);

            scene.add(paw);
            activeEffects.push({
                mesh: paw, startTime: Date.now() + delay, duration: 400, type: 'jibanyanPaw',
                startPosition: startPos,
                targetPosition: targetPosition.clone().add(new THREE.Vector3(
                    (Math.random() - 0.5) * 3, 3, (Math.random() - 0.5) * 3
                ))
            });
        }

        function createExplosionEffect(position) {
            const particleCount = 100;
            const particleMat = new THREE.MeshStandardMaterial({
                color: 0xd9534f, transparent: true, opacity: 1.0
            });

            for (let i = 0; i < particleCount; i++) {
                const particleGeo = new THREE.BoxGeometry(1, 1, 1);
                const particle = new THREE.Mesh(particleGeo, particleMat.clone());
                particle.position.copy(position);
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 50, (Math.random()) * 50, (Math.random() - 0.5) * 50
                );
                scene.add(particle);
                activeEffects.push({
                    mesh: particle, startTime: Date.now(), duration: 1000 + Math.random() * 500,
                    type: 'explosionParticle', velocity: velocity
                });
            }
        }

        function createDogWaveEffect() {
            const waveCount = 5;
            const waveSpeed = 80;
            const direction = new THREE.Vector3().subVectors(player.mesh.position, boss.mesh.position).normalize();
            const perpendicular = new THREE.Vector3(-direction.z, 0, direction.x);

            for (let i = 0; i < waveCount; i++) {
                const offset = (i - Math.floor(waveCount / 2)) * TILE_SIZE * 0.8;
                const startPos = new THREE.Vector3()
                    .copy(boss.mesh.position)
                    .add(perpendicular.clone().multiplyScalar(offset))
                    .sub(direction.clone().multiplyScalar(TILE_SIZE));

                const dogModel = createDogModel({isShadow: true});
                dogModel.position.copy(startPos);
                dogModel.lookAt(player.mesh.position);
                scene.add(dogModel);

                activeEffects.push({
                    mesh: dogModel, startTime: Date.now(), duration: 2000,
                    type: 'dogWave', velocity: direction.clone().multiplyScalar(waveSpeed)
                });
            }
        }
        
        function createMedalEffect(position) {
            const medalGeo = new THREE.CylinderGeometry(2, 2, 0.5, 16);
            const medalMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.3, transparent: true });
            const medal = new THREE.Mesh(medalGeo, medalMat);
            medal.position.copy(position).add(new THREE.Vector3(0, 3, 0));
            scene.add(medal);

            activeEffects.push({
                mesh: medal, startTime: Date.now(), duration: 1500, type: 'medal'
            });

            const synth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            synth.triggerAttackRelease("C6", "8n", Tone.now());
        }

        // --- Model Creation ---
        function createDogModel({isShadow = false, isAlly = false, isLegendary = false} = {}) {
            const group = new THREE.Group();
            let color = isShadow ? 0x444444 : 0xcd853f;
            if (isLegendary) {
                color = 0xffd700; // Gold for legendary
            } else if (isAlly) {
                color = 0x63b3ed; // Blue for allies
            }

            const dogMat = new THREE.MeshStandardMaterial({ 
                color: color, roughness: 0.7, transparent: isShadow,
                opacity: isShadow ? 0.7 : 1.0,
                emissive: isLegendary ? color : 0x000000,
                emissiveIntensity: isLegendary ? 0.5 : 0
            });

            const bodyGeo = new THREE.CapsuleGeometry(2, 3, 4, 16);
            const body = new THREE.Mesh(bodyGeo, dogMat);
            body.position.y = 3.5;
            group.add(body);

            const snoutGeo = new THREE.BoxGeometry(1.5, 1, 2);
            const snout = new THREE.Mesh(snoutGeo, dogMat);
            snout.position.set(0, 3.5, 2);
            group.add(snout);

            const earGeo = new THREE.BoxGeometry(0.5, 2, 1);
            const earL = new THREE.Mesh(earGeo, dogMat);
            earL.position.set(-2, 5, 0.5);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, dogMat);
            earR.position.set(2, 5, 0.5);
            group.add(earR);

            const tailGeo = new THREE.CylinderGeometry(0.3, 0.3, 3, 8);
            const tail = new THREE.Mesh(tailGeo, dogMat);
            tail.position.set(0, 3, -2);
            tail.rotation.x = Math.PI / 4;
            group.add(tail);

            if (!isAlly && !isLegendary) {
                const swirlGeo = new THREE.TorusGeometry(1, 0.2, 8, 16);
                const swirlMat = new THREE.MeshStandardMaterial({ color: 0xf6ad55 });
                const swirl = new THREE.Mesh(swirlGeo, swirlMat);
                swirl.position.set(-2.1, 3.5, 0);
                swirl.rotation.y = Math.PI / 2;
                group.add(swirl);
            }

            return group;
        }

        // --- Combat & Enemy Logic ---
        function handleEnemyDefeat(attackedEnemies, count) {
            const oldKillCount = player.killCount;
            attackedEnemies.filter(e => e.hp <= 0).forEach(deadEnemy => {
                const index = enemies.findIndex(e => e.id === deadEnemy.id);
                if (index > -1) {
                    const deadEnemyPosition = deadEnemy.mesh.position.clone();
                    scene.remove(deadEnemy.mesh);
                    enemies.splice(index, 1);
                    player.addSoultimate(15);

                    if (Math.random() < 0.25) {
                        player.yokaiMedals++;
                        showMessage("You got a Yo-kai Medal!", 2500);
                        createMedalEffect(deadEnemyPosition);
                        if (player.yokaiMedals >= 45 && !player.hasYokaiWatch) {
                            player.hasYokaiWatch = true;
                            updateStatsUI();
                            startBossFight();
                        }
                    }
                }
            });

            if (count > 0) {
                const oldLevel = player.level;
                player.level += count;
                player.killCount += count;
                
                checkUnlocks(oldLevel);
                player.updateStats();
                updateStatsUI();
            }
            
            if (Math.floor(player.killCount / KILLS_PER_RANK) > Math.floor(oldKillCount / KILLS_PER_RANK)) {
                if (!["Legendary", "Legendary VIP", "UltiMeow"].includes(player.rank)) {
                    rankUp(Math.floor(player.killCount / KILLS_PER_RANK));
                }
            }

            if (count > 0 && !bossFightActive) {
                spawnEnemies(count);
            }
        }
        
        function rankUp(newRankIndex) {
            if (newRankIndex < RANK_ORDER.length) {
                player.rank = RANK_ORDER[newRankIndex];
                showMessage(`Rank Up! You are now Rank ${player.rank}!`, 3000);
                if (player.rank === 'S' && !player.aura) {
                    const auraLight = new THREE.PointLight(0xff0000, 3, 30);
                    auraLight.position.y = 5;
                    player.mesh.add(auraLight);
                    player.aura = auraLight;
                }
                updateStatsUI();
            }
        }

        function checkUnlocks(oldLevel) {
            if (player.level >= 500 && oldLevel < 500) {
                player.rank = "UltiMeow";
                player.baseAttack += 9999999999999999999999999999;
                player.baseHp += 99999;
                showMessage("RANK UP! ULTIMEOW! ATK + ??? | HP +99,999!", 5000);
            } else if (player.level >= 300 && oldLevel < 300) {
                player.rank = "Legendary VIP";
                player.baseAttack += 10000000;
                showMessage("RANK UP! LEGENDARY VIP! ATK +10,000,000!", 4000);
            } else if (player.level >= 100 && oldLevel < 100) {
                player.rank = "Legendary";
                player.baseAttack += 5000;
                showMessage("RANK UP! LEGENDARY! ATK +5,000!", 4000);
            }
            
            if (player.level >= 50 && oldLevel < 50) {
                evolvePlayer();
            }
        }

        function evolvePlayer() {
            if (player.isEvolved) return;
            player.isEvolved = true;
            showMessage("What?! Sprigatitonyan is evolving!", 4000);

            player.name = "Ultranyan";
            player.materials.body.color.set(0x4287f5); // Blue
            player.materials.paw.color.set(0x000000); // Black
            player.materials.eye.color.set(0x34d399); // Green
            player.materials.nick.color.set(0x2a5a9e); // Darker blue for nick
            pawsOfFuryUI.textContent = "A: Glitch Wave";
            
            player.baseHp += 1000;
            player.baseAttack += 1000;
            showMessage("Stats greatly increased!", 3000);

            const flashLight = new THREE.PointLight(0xffffff, 10, 100);
            flashLight.position.copy(player.mesh.position);
            scene.add(flashLight);
            activeEffects.push({
                mesh: flashLight,
                startTime: Date.now(),
                duration: 1500,
                type: 'evolutionFlash'
            });
        }

        function spawnEnemies(count) {
            const occupied = new Set(enemies.map(e => `${e.gridX},${e.gridY}`));
            occupied.add(`${player.gridX},${player.gridY}`);

            for (let i = 0; i < count; i++) {
                let gridX, gridY, attempts = 0;
                do {
                    gridX = Math.floor(Math.random() * MAP_SIZE);
                    gridY = Math.floor(Math.random() * MAP_SIZE);
                    attempts++;
                } while (occupied.has(`${gridX},${gridY}`) && attempts < 50);

                if (attempts < 50) {
                    const id = `enemy-${nextEnemyId++}`;
                    const enemy = { id, hp: 2600, attack: 100, gridX, gridY };
                    
                    enemy.mesh = createDogModel();
                    const pos = gridToWorld(gridX, gridY);
                    enemy.mesh.position.set(pos.x, 0, pos.z);
                    scene.add(enemy.mesh);
                    enemies.push(enemy);
                    occupied.add(`${gridX},${gridY}`);
                }
            }
        }
        
        // --- Summoning Logic ---
        function summonAlly() {
            if (player.yokaiMedals <= 0 || player.isAttacking) {
                showMessage(player.isAttacking ? "Cannot summon while attacking!" : "No medals to summon!", 2000);
                return;
            }
            player.isAttacking = true;
            player.yokaiMedals--;
            updateStatsUI();
            
            const isLegendary = true; // Set to 100% chance
            const summonPosition = player.mesh.position.clone().add(new THREE.Vector3(0, 5, 10));

            createSummoningJingle(isLegendary);
            createSummoningPortalEffect(summonPosition, isLegendary);

            setTimeout(() => {
                if (isLegendary) {
                    showMessage("WOW! A Legendary Yo-kai has joined you permanently!", 4000);
                } else {
                    showMessage("Go, my friend!", 2000);
                }

                const id = `ally-${nextAllyId++}`;
                const allyMesh = createDogModel({isAlly: true, isLegendary: isLegendary});
                allyMesh.position.copy(summonPosition);
                scene.add(allyMesh);

                const ally = {
                    id: id, mesh: allyMesh, attack: isLegendary ? 500 : 150,
                    attackCooldown: 1500, lastAttackTime: 0,
                    spawnTime: Date.now(), isLegendary: isLegendary
                };
                alliedYoKai.push(ally);
                
                const auraColor = isLegendary ? 0xffd700 : 0x63b3ed;
                const auraDuration = isLegendary ? Infinity : ALLY_LIFETIME;
                createAuraEffect(ally.mesh, auraColor, `ally-aura-${ally.id}`, auraDuration);
            }, 1000); // Delay appearance to sync with portal

            setTimeout(() => { player.isAttacking = false; }, 2500); // Cooldown for summoning
        }

        function createSummoningPortalEffect(position, isLegendary) {
            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;
            const fragmentShader = `
                varying vec2 vUv;
                uniform float u_time;
                uniform vec3 u_color;

                void main() {
                    vec2 uv = vUv - 0.5;
                    float dist = length(uv);
                    
                    float angle = atan(uv.y, uv.x);
                    float spiral = angle + (1.0 / (dist + 0.1)) * u_time * 2.0;
                    
                    float colorValue = sin(spiral * 5.0) * 0.5 + 0.5;
                    
                    float alpha = smoothstep(0.5, 0.4, dist);
                    
                    gl_FragColor = vec4(u_color * colorValue, alpha);
                }
            `;

            const portalGeo = new THREE.PlaneGeometry(TILE_SIZE * 2, TILE_SIZE * 2);
            const portalMat = new THREE.ShaderMaterial({
                uniforms: {
                    u_time: { value: 0.0 },
                    u_color: { value: isLegendary ? new THREE.Color(0xffd700) : new THREE.Color(0x63b3ed) }
                },
                vertexShader,
                fragmentShader,
                transparent: true,
                depthWrite: false
            });

            const portal = new THREE.Mesh(portalGeo, portalMat);
            portal.position.copy(position);
            scene.add(portal);

            activeEffects.push({
                mesh: portal, startTime: Date.now(), duration: 2000,
                type: 'summoningPortal'
            });
        }
        
        // --- Boss Logic ---
        function startBossFight() {
            if (bossFightActive) return;
            bossFightActive = true;
            showMessage("Your Yo-kai Watch reacts! A BOSS appears!", 4000);
            
            // Clear normal enemies
            [...enemies].forEach(enemy => scene.remove(enemy.mesh));
            enemies.length = 0;

            // Preserve legendary allies, remove normal ones
            const nonLegendaryAllies = alliedYoKai.filter(ally => !ally.isLegendary);
            nonLegendaryAllies.forEach(ally => {
                scene.remove(ally.mesh);
                const auraIndex = activeEffects.findIndex(e => e.effectId === `ally-aura-${ally.id}`);
                if (auraIndex > -1) {
                    scene.remove(activeEffects[auraIndex].mesh);
                    activeEffects.splice(auraIndex, 1);
                }
            });
            alliedYoKai.splice(0, alliedYoKai.length, ...alliedYoKai.filter(ally => ally.isLegendary));

            bossHealthBar.style.display = 'block';
            tauntUI.classList.remove('hidden');
            playBossMusic();

            spawnBoss();
            updateStatsUI();
            bossAttackInterval = setInterval(bossAttack, 4000);
        }

        function spawnBoss() {
            let gridX, gridY;
            do {
                gridX = Math.floor(Math.random() * MAP_SIZE);
                gridY = Math.floor(Math.random() * MAP_SIZE);
            } while (gridX === player.gridX && gridY === player.gridY);
            
            let bossMaxHp = 10000;
            if (player.rank === "UltiMeow") {
                bossMaxHp = 1000000000000000000000000000;
                showMessage("The Alpha Dog is empowered by your UltiMeow rank!", 4000);
            }
            const group = new THREE.Group();
            const mat = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.4 });
            
            const geo = new THREE.BoxGeometry(TILE_SIZE, TILE_SIZE, TILE_SIZE);
            const body = new THREE.Mesh(geo, mat);
            group.add(body);
            
            const eyeGeo = new THREE.BoxGeometry(2, 2, 1);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
            eyeL.position.set(-2.5, 2.5, 5.1);
            group.add(eyeL);
            const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
            eyeR.position.set(2.5, 2.5, 5.1);
            group.add(eyeR);

            const snoutGeo = new THREE.BoxGeometry(4, 3, 3);
            const snout = new THREE.Mesh(snoutGeo, mat);
            snout.position.set(0, -2, 6);
            group.add(snout);

            const earGeo = new THREE.BoxGeometry(2, 4, 2);
            const earL = new THREE.Mesh(earGeo, mat);
            earL.position.set(-4, 6, 0);
            group.add(earL);
            const earR = new THREE.Mesh(earGeo, mat);
            earR.position.set(4, 6, 0);
            group.add(earR);

            boss = { 
                maxHp: bossMaxHp, hp: bossMaxHp, attack: 50, gridX, gridY, 
                attackModifier: 1.0, mesh: group, isMoving: false,
                targetPosition: new THREE.Vector3(), startPosition: new THREE.Vector3(),
                moveProgress: 0
            };

            const pos = gridToWorld(gridX, gridY);
            boss.mesh.position.set(pos.x, TILE_SIZE / 2, pos.z);
            boss.startPosition.copy(boss.mesh.position);
            boss.targetPosition.copy(boss.mesh.position);
            scene.add(boss.mesh);
        }

        function bossAttack() {
            if (gameOver || !boss || boss.isMoving) return;

            showMessage("Boss uses Assemble the Pack!", 2000);
            createDogWaveEffect();
            
            setTimeout(() => {
                const attackRadius = TILE_SIZE * 2.5;
                if (player.mesh.position.distanceTo(boss.mesh.position) < attackRadius) {
                    const damage = Math.round(boss.attack * boss.attackModifier);
                    player.hp -= damage;
                    if (player.hp < 0) player.hp = 0;
                    player.addSoultimate(damage / 2);
                    updateStatsUI();
                    showMessage(`The pack overruns you! -${damage} HP`, 2000);
                    if (player.hp <= 0) endGame(false);
                }
            }, 1000);

            setTimeout(() => {
                if (gameOver || !boss) return;
                const possibleMoves = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                const move = possibleMoves[Math.floor(Math.random() * possibleMoves.length)];
                const newX = boss.gridX + move[0];
                const newY = boss.gridY + move[1];

                if (newX >= 0 && newX < MAP_SIZE && newY >= 0 && newY < MAP_SIZE && (newX !== player.gridX || newY !== player.gridY)) {
                    boss.isMoving = true;
                    boss.gridX = newX;
                    boss.gridY = newY;
                    boss.startPosition.copy(boss.mesh.position);
                    const targetPos = gridToWorld(newX, newY);
                    targetPos.y = TILE_SIZE / 2;
                    boss.targetPosition.copy(targetPos);
                    boss.moveProgress = 0;
                }
            }, 2000);
        }

        // --- Game State & Animation ---
        function endGame(didWin) {
            gameOver = true;
            clearInterval(bossAttackInterval);
            stopAllMusic();
            if (didWin) {
                winMessageElement.style.display = 'block';
                activeEffects.push({ mesh: boss.mesh, startTime: Date.now(), duration: 1000, type: 'shrink' });
                
                const synth = new Tone.Synth().toDestination();
                const now = Tone.now();
                const notes = ["C5", "E5", "G5", "C6", "G5", "E5", "C5"];
                notes.forEach((note, i) => {
                    synth.triggerAttackRelease(note, "8n", now + i * 0.15);
                });
            } else {
                showMessage("Game Over!", 5000);
            }
        }

        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const now = Date.now();

            // Player Movement
            if (player.isMoving) {
                player.moveProgress += delta * 4;
                const easedProgress = 1 - Math.pow(1 - player.moveProgress, 3);
                
                player.mesh.position.lerpVectors(player.startPosition, player.targetPosition, easedProgress);
                player.mesh.position.y = player.startPosition.y + Math.sin(Math.min(player.moveProgress, 1) * Math.PI) * 5;

                if (player.moveProgress >= 1) {
                    player.isMoving = false;
                    player.moveProgress = 0;
                    player.mesh.position.copy(player.targetPosition);
                    player.mesh.position.y = 0;
                    
                    if (!bossFightActive) {
                        const enemyOnTile = enemies.find(e => e.gridX === player.gridX && e.gridY === player.gridY);
                        if (enemyOnTile) {
                            player.hp -= enemyOnTile.attack;
                            if (player.hp < 0) player.hp = 0;
                            player.addSoultimate(10);
                            updateStatsUI();
                            showMessage(`Landed on a Dog! Ouch! -${enemyOnTile.attack} HP`, 2000);
                            if (player.hp <= 0) endGame(false);
                        }
                    }
                }
            }

            // Boss Movement
            if (boss && boss.isMoving) {
                boss.moveProgress += delta * 2; // Boss moves slower
                const easedProgress = 1 - Math.pow(1 - boss.moveProgress, 3);
                boss.mesh.position.lerpVectors(boss.startPosition, boss.targetPosition, easedProgress);
                if (boss.moveProgress >= 1) {
                    boss.isMoving = false;
                    boss.moveProgress = 0;
                    boss.mesh.position.copy(boss.targetPosition);
                }
            }

            // Allied Yo-kai AI
            for (let i = alliedYoKai.length - 1; i >= 0; i--) {
                const ally = alliedYoKai[i];

                if (!ally.isLegendary && now - ally.spawnTime > ALLY_LIFETIME) {
                    scene.remove(ally.mesh);
                    const auraIndex = activeEffects.findIndex(e => e.effectId === `ally-aura-${ally.id}`);
                    if (auraIndex > -1) {
                        scene.remove(activeEffects[auraIndex].mesh);
                        activeEffects.splice(auraIndex, 1);
                    }
                    alliedYoKai.splice(i, 1);
                    continue;
                }

                let nearestEnemy = null;
                let minDistance = Infinity;
                const potentialTargets = bossFightActive ? (boss ? [boss] : []) : enemies;
                potentialTargets.forEach(enemy => {
                    const distance = ally.mesh.position.distanceTo(enemy.mesh.position);
                    if (distance < minDistance) {
                        minDistance = distance;
                        nearestEnemy = enemy;
                    }
                });

                if (nearestEnemy) {
                    const direction = new THREE.Vector3().subVectors(nearestEnemy.mesh.position, ally.mesh.position).normalize();
                    const speed = 25 * delta;
                    const attackRange = TILE_SIZE * 1.2;
                    if (minDistance < attackRange) {
                        if (now - ally.lastAttackTime > ally.attackCooldown) {
                            ally.lastAttackTime = now;
                            createSlashEffect(ally.mesh.position, 0);

                            if (bossFightActive) {
                                boss.hp -= ally.attack;
                                if (boss.hp < 0) boss.hp = 0;
                                updateStatsUI();
                                if (boss.hp <= 0) endGame(true);
                            } else {
                                nearestEnemy.hp -= ally.attack;
                                if (nearestEnemy.hp <= 0) {
                                    handleEnemyDefeat([nearestEnemy], 1);
                                }
                            }
                        }
                    } else {
                        ally.mesh.position.add(direction.multiplyScalar(speed));
                    }
                    ally.mesh.lookAt(nearestEnemy.mesh.position);
                }
            }
            
            // Active Effects
            for (let i = activeEffects.length - 1; i >= 0; i--) {
                const effect = activeEffects[i];
                const age = now - effect.startTime;
                let progress = age / effect.duration;
                if (progress < 0) continue;
                if (progress > 1) progress = 1;

                switch(effect.type) {
                    case 'slash':
                        effect.mesh.material.opacity = 1.0 - progress;
                        effect.mesh.scale.set(progress, progress, progress);
                        break;
                    case 'clawRushDash':
                        effect.mesh.material.opacity = 1.0 - progress;
                        effect.mesh.position.lerpVectors(effect.startPosition, effect.targetPosition, progress);
                        break;
                    case 'jibanyanPaw':
                        effect.mesh.position.lerpVectors(effect.startPosition, effect.targetPosition, progress);
                        if (!effect.mesh.material.transparent) effect.mesh.material.transparent = true;
                        effect.mesh.material.opacity = 1.0 - progress;
                        break;
                    case 'sword':
                        effect.mesh.position.lerpVectors(effect.startPosition, effect.targetPosition, progress);
                        effect.mesh.traverse(child => {
                            if (child.isMesh) {
                                if (!child.material.transparent) child.material.transparent = true;
                                child.material.opacity = 1.0 - progress;
                            }
                        });
                        break;
                    case 'explosionParticle':
                        const gravity = 20.0;
                        effect.velocity.y -= gravity * delta;
                        effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));
                        effect.mesh.material.opacity = 1.0 - progress;
                        break;
                    case 'dogWave':
                        effect.mesh.position.add(effect.velocity.clone().multiplyScalar(delta));
                        effect.mesh.traverse(child => {
                            if (child.isMesh) child.material.opacity = 1.0 - progress;
                        });
                        break;
                    case 'shrink':
                        effect.mesh.scale.set(1.0 - progress, 1.0 - progress, 1.0 - progress);
                        break;
                    case 'evolutionFlash':
                        effect.mesh.intensity = (1.0 - Math.abs(progress - 0.5) * 2) * 20;
                        break;
                    case 'aura':
                        if (effect.target) {
                            effect.mesh.position.copy(effect.target.position);
                        }
                        if (effect.duration !== Infinity) {
                            effect.mesh.material.opacity = (1.0 - progress) * 0.4;
                        }
                        break;
                    case 'medal':
                        effect.mesh.rotation.y += delta * 5;
                        effect.mesh.position.y += delta * 5;
                        effect.mesh.material.opacity = 1.0 - progress;
                        break;
                    case 'summoningPortal':
                        effect.mesh.material.uniforms.u_time.value += delta;
                        effect.mesh.quaternion.copy(camera.quaternion); // Always face camera
                        
                        const scaleProgress = Math.min(age / 500, 1.0); // Grow in 0.5s
                        const scale = Math.sin(scaleProgress * Math.PI / 2);
                        effect.mesh.scale.set(scale, scale, scale);

                        if (progress > 0.75) { // Fade out in last 25% of life
                            effect.mesh.material.opacity = (1.0 - progress) * 4.0;
                        }
                        break;
                }

                if (progress >= 1 && effect.duration !== Infinity) {
                    scene.remove(effect.mesh);
                    activeEffects.splice(i, 1);
                }
            }

            if (player.aura) {
                player.aura.intensity = 2 + Math.sin(now * 0.005) * 1.5;
            }

            const targetCameraPosition = new THREE.Vector3().copy(player.mesh.position).add(cameraOffset);
            camera.position.lerp(targetCameraPosition, 0.05);
            camera.lookAt(player.mesh.position);

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            const container = document.getElementById('canvas-container');
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }
        window.addEventListener('resize', onWindowResize);
        
        const handleKeyDown = (e) => {
            if (!isAudioStarted) {
                Tone.start();
                isAudioStarted = true;
                playAdventureMusic();
            }
            if (gameOver) return;
            switch (e.key) {
                case 'ArrowUp': movePlayer(0, -1); break;
                case 'ArrowDown': movePlayer(0, 1); break;
                case 'ArrowLeft': movePlayer(-1, 0); break;
                case 'ArrowRight': movePlayer(1, 0); break;
                case 'y': case 'Y': sharpClawsAttack(); break;
                case 'a': case 'A': pawsOfFuryAttack(); break;
                case 't': case 'T': catWaveAttack(); break;
                case 'e': case 'E': clawRushAttack(); break;
                case 'r': case 'R': inspiritBoss(); break;
                case 'g': case 'G': tauntBoss(); break;
                case 's': case 'S': summonAlly(); break;
                case 'k': case 'K': gigantaBladeAttack(); break;
            }
        };
        window.addEventListener('keydown', handleKeyDown);

        // --- Music ---
        let adventureMusic = {};
        let bossMusic = {};

        function stopAllMusic() {
            if (adventureMusic.melody) adventureMusic.melody.stop();
            if (adventureMusic.bass) adventureMusic.bass.stop();
            if (bossMusic.melody) bossMusic.melody.stop();
            if (bossMusic.bass) bossMusic.bass.stop();
            Tone.Transport.stop();
            Tone.Transport.cancel();
        }

        function createSummoningJingle(isLegendary) {
            const synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: 'triangle' },
                envelope: { attack: 0.01, decay: 0.3, sustain: 0.1, release: 0.4 }
            }).toDestination();
            synth.volume.value = -6;
            const now = Tone.now();

            if(isLegendary) {
                // "Imaginary, Incendiary... Legendary!" jingle
                const legendarySynth = new Tone.PolySynth(Tone.Synth, {
                    oscillator: { type: 'fatsawtooth' },
                    envelope: { attack: 0.05, decay: 0.5, sustain: 0.3, release: 0.6 }
                }).toDestination();
                legendarySynth.volume.value = -4;
                
                const notes = ["C4", "E4", "G4", "C5", "E5", "G5", "C6"];
                notes.forEach((note, i) => {
                    legendarySynth.triggerAttackRelease(note, "16n", now + i * 0.12);
                });
                legendarySynth.triggerAttackRelease(["C5", "E5", "G5"], "2n", now + notes.length * 0.12);

            } else {
                // "Alarming, Boom boom... Charming!" jingle
                const notes = [
                    "G5", "G5", "A5", "G5", "F5", "E5", "D5",
                    "C5", "C5", "D5", "E5", "F5", "G5"
                ];
                const timings = [0, 0.15, 0.3, 0.45, 0.6, 0.75, 0.9, 1.2, 1.35, 1.5, 1.65, 1.8, 1.95];
                
                notes.forEach((note, i) => {
                    synth.triggerAttackRelease(note, "16n", now + timings[i]);
                });
                synth.triggerAttackRelease(["C5", "E5", "G5"], "4n", now + 2.2);
            }
        }

        function playAdventureMusic() {
            stopAllMusic();
            const melodySynth = new Tone.FMSynth({
                harmonicity: 1.5, modulationIndex: 1.2, oscillator: { type: "sine" },
                envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 },
            }).toDestination();
            const bassSynth = new Tone.MonoSynth({ oscillator: { type: "fatsawtooth" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            bassSynth.volume.value = -12;

            const melodyNotes = ["G4", "A4", "B4", "G4", "B4", "A4", "G4", "E4", "D4", "E4", "G4", null, "G4", "A4", "B4", "C5"];
            const bassNotes = ["G2", "G2", "C2", "C2", "D2", "D2", "G2", "D2"];

            adventureMusic.melody = new Tone.Sequence((time, note) => {
                if(note) melodySynth.triggerAttackRelease(note, "16n", time);
            }, melodyNotes, "8n").start(0);

            adventureMusic.bass = new Tone.Sequence((time, note) => {
                if(note) bassSynth.triggerAttackRelease(note, "4n", time);
            }, bassNotes, "2n").start(0);

            Tone.Transport.bpm.value = 135;
            Tone.Transport.start();
        }

        function playBossMusic() {
            stopAllMusic();
            const melodySynth = new Tone.FMSynth({ harmonicity: 3, modulationIndex: 10, detune: 0, oscillator: { type: "sine" }, envelope: { attack: 0.01, decay: 0.1, sustain: 0.5, release: 0.1 }, modulation: { type: "square" }, modulationEnvelope: { attack: 0.5, decay: 0.01 } }).toDestination();
            const bassSynth = new Tone.MonoSynth({ oscillator: { type: "fatsquare" }, envelope: { attack: 0.01, decay: 0.2, sustain: 0.1, release: 0.2 } }).toDestination();
            bassSynth.volume.value = -8;

            const melodyNotes = ["C3", "C#3", "D3", "C#3", "C3", "G#2", "A#2", "G#2"];
            const bassNotes = ["C2", null, "C2", "G#1", "C2", null, "C2", "A#1"];

            bossMusic.melody = new Tone.Sequence((time, note) => {
                if(note) melodySynth.triggerAttackRelease(note, "8n", time);
            }, melodyNotes, "8n").start(0);

            bossMusic.bass = new Tone.Sequence((time, note) => {
                if(note) bassSynth.triggerAttackRelease(note, "4n", time);
            }, bassNotes, "4n").start(0);

            Tone.Transport.bpm.value = 140;
            Tone.Transport.start();
        }

        function init() {
            createPlayer();
            updateStatsUI();
            spawnEnemies(4);
            onWindowResize();
            animate();
        }
        
        init();
    </script>
</body>
</html>
